import{AsyncLocalStorage}from"node:async_hooks";const noop=()=>{},disabledRegexps=[],enabledRegexps=[],context=new AsyncLocalStorage;export function runWithLogger(e,o){return context.run(e,o)}function getLogFunc(e,o){if(!e.enabled||!(e.level>=o||factory.level>=o))return noop;{const e=context.getStore();if(!e)return noop;switch(o){case 0:case 1:return e.error.bind(e);case 2:return e.warn.bind(e);case 3:return e.info.bind(e);case 4:return e.log.bind(e);default:return e.debug.bind(e)}}}const loggers={};export const factory=e=>{let o=loggers[e];if(o)return o;let n=factory.level;return o=loggers[e]={get assert(){return noop},get error(){return getLogFunc(o,1)},get warn(){return getLogFunc(o,2)},get info(){return getLogFunc(o,3)},get write(){return getLogFunc(o,3)},get log(){return getLogFunc(o,4)},get debug(){return getLogFunc(o,5)},get trace(){return getLogFunc(o,6)},get dir(){return getLogFunc(o,5)},get table(){return getLogFunc(o,5)},get time(){return noop},get timeEnd(){return noop},get timeLog(){return noop},get level(){return n},set level(e){n=e},enabled:enabled(e,{disabledRegexps:disabledRegexps,enabledRegexps:enabledRegexps})}};const logLevels={error:1,warn:2,info:3,log:4,debug:5,trace:6};function enabled(e,{disabledRegexps:o,enabledRegexps:n}){if("*"===e[e.length-1])return!0;let t,r;for(t=0,r=o.length;t<r;t++)if(o[t].test(e))return!1;for(t=0,r=n.length;t<r;t++)if(n[t].test(e))return!0;return!1}function processNamespaces(e,{disabledRegexps:o,enabledRegexps:n},t){const r=("string"==typeof e?e:"").split(/[\s,]+/),l=r.length;for(let t=0;t<l;t++)r[t]&&("-"===(e=r[t].replace(/\*/g,".*?"))[0]?o.push(new RegExp("^"+e.substr(1)+"$")):n.push(new RegExp("^"+e+"$")));for(const e of Object.keys(loggers))t(e,enabled(e,{disabledRegexps:o,enabledRegexps:n}))}factory.level=2,factory.disable=()=>{disabledRegexps.splice(0,disabledRegexps.length),enabledRegexps.splice(0,enabledRegexps.length);for(const e of Object.keys(loggers))loggers[e].enabled=!1},factory.enable=e=>{disabledRegexps.splice(0,disabledRegexps.length),enabledRegexps.splice(0,enabledRegexps.length),processNamespaces(e=""===e?"*":e||"*",{disabledRegexps:disabledRegexps,enabledRegexps:enabledRegexps},((e,o)=>loggers[e].enabled=o))};export function hookup(){hook(factory)}if("undefined"!=typeof process){let e=process.env.NAMED_LOGS;e?factory.enable(e):factory.disable(),e=process.env.NAMED_LOGS_LEVEL,e&&(factory.level=logLevels[e]||parseInt(e)||factory.level)}globalThis._logFactory=factory,globalThis._runWithLogger=runWithLogger;const noopLogger={assert:noop,error:noop,warn:noop,info:noop,log:noop,debug:noop,dir:noop,table:noop,trace:noop,write:noop,time:noop,timeEnd:noop,timeLog:noop};let _factory=factory;export function hook(e){"undefined"!=typeof globalThis&&(globalThis._logFactory=e),_factory=e}const fallbackFactory=e=>{let o;const n=new Proxy({},{get(n,t,r){if(o)return o[t];const l=_getFactory();return l?(o=l(e),o[t]):noop}});return n};function _getFactory(){return _factory||(null===globalThis||void 0===globalThis?void 0:globalThis._logFactory)}export function logs(e,o){const n=_getFactory();return n?n(e):(null==o?void 0:o.fallbackOnProxy)?"boolean"==typeof o.fallbackOnProxy?o.fallbackOnProxy?fallbackFactory(e):noopLogger:"string"==typeof o.fallbackOnProxy&&"undefined"!=typeof process&&(null===process||void 0===process?void 0:process.env[o.fallbackOnProxy])?fallbackFactory(e):noopLogger:noopLogger}