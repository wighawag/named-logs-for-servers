"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.factory=void 0,exports.runWithLogger=runWithLogger,exports.hookup=hookup,exports.hook=hook,exports.logs=logs;const node_async_hooks_1=require("node:async_hooks"),noop=()=>{},disabledRegexps=[],enabledRegexps=[],context=new node_async_hooks_1.AsyncLocalStorage;function runWithLogger(e,o){return context.run(e,o)}function getLogFunc(e,o){if(!e.enabled||!(e.level>=o||exports.factory.level>=o))return noop;{const e=context.getStore();if(!e)return noop;switch(o){case 0:case 1:return e.error.bind(e);case 2:return e.warn.bind(e);case 3:return e.info.bind(e);case 4:return e.log.bind(e);default:return e.debug.bind(e)}}}const loggers={},factory=e=>{let o=loggers[e];if(o)return o;let t=exports.factory.level;return o=loggers[e]={get assert(){return noop},get error(){return getLogFunc(o,1)},get warn(){return getLogFunc(o,2)},get info(){return getLogFunc(o,3)},get write(){return getLogFunc(o,3)},get log(){return getLogFunc(o,4)},get debug(){return getLogFunc(o,5)},get trace(){return getLogFunc(o,6)},get dir(){return getLogFunc(o,5)},get table(){return getLogFunc(o,5)},get time(){return noop},get timeEnd(){return noop},get timeLog(){return noop},get level(){return t},set level(e){t=e},enabled:enabled(e,{disabledRegexps:disabledRegexps,enabledRegexps:enabledRegexps})}};exports.factory=factory;const logLevels={error:1,warn:2,info:3,log:4,debug:5,trace:6};function enabled(e,{disabledRegexps:o,enabledRegexps:t}){if("*"===e[e.length-1])return!0;let r,n;for(r=0,n=o.length;r<n;r++)if(o[r].test(e))return!1;for(r=0,n=t.length;r<n;r++)if(t[r].test(e))return!0;return!1}function processNamespaces(e,{disabledRegexps:o,enabledRegexps:t},r){const n=("string"==typeof e?e:"").split(/[\s,]+/),s=n.length;for(let r=0;r<s;r++)n[r]&&("-"===(e=n[r].replace(/\*/g,".*?"))[0]?o.push(new RegExp("^"+e.substr(1)+"$")):t.push(new RegExp("^"+e+"$")));for(const e of Object.keys(loggers))r(e,enabled(e,{disabledRegexps:o,enabledRegexps:t}))}function hookup(){hook(exports.factory)}if(exports.factory.level=2,exports.factory.disable=()=>{disabledRegexps.splice(0,disabledRegexps.length),enabledRegexps.splice(0,enabledRegexps.length);for(const e of Object.keys(loggers))loggers[e].enabled=!1},exports.factory.enable=e=>{disabledRegexps.splice(0,disabledRegexps.length),enabledRegexps.splice(0,enabledRegexps.length),processNamespaces(e=""===e?"*":e||"*",{disabledRegexps:disabledRegexps,enabledRegexps:enabledRegexps},((e,o)=>loggers[e].enabled=o))},"undefined"!=typeof process){let e=process.env.NAMED_LOGS;e?exports.factory.enable(e):exports.factory.disable(),e=process.env.NAMED_LOGS_LEVEL,e&&(exports.factory.level=logLevels[e]||parseInt(e)||exports.factory.level)}globalThis._logFactory=exports.factory,globalThis._runWithLogger=runWithLogger;const noopLogger={assert:noop,error:noop,warn:noop,info:noop,log:noop,debug:noop,dir:noop,table:noop,trace:noop,write:noop,time:noop,timeEnd:noop,timeLog:noop};let _factory=exports.factory;function hook(e){"undefined"!=typeof globalThis&&(globalThis._logFactory=e),_factory=e}const fallbackFactory=e=>{let o;const t=new Proxy({},{get(t,r,n){if(o)return o[r];const s=_getFactory();return s?(o=s(e),o[r]):noop}});return t};function _getFactory(){return _factory||(null===globalThis||void 0===globalThis?void 0:globalThis._logFactory)}function logs(e,o){const t=_getFactory();return t?t(e):(null==o?void 0:o.fallbackOnProxy)?"boolean"==typeof o.fallbackOnProxy?o.fallbackOnProxy?fallbackFactory(e):noopLogger:"string"==typeof o.fallbackOnProxy&&"undefined"!=typeof process&&(null===process||void 0===process?void 0:process.env[o.fallbackOnProxy])?fallbackFactory(e):noopLogger:noopLogger}